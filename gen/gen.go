package gen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"strings"
	"text/template"
)

// TargetTypes は処理対象の型名
type TargetTypes []string

// contains はxがrcvに含まれるときにtrueを返す.
func (rcv TargetTypes) contains(x string) bool {
	for _, v := range rcv {
		if v == x {
			return true
		}
	}
	return false
}

/*
importPackages はimportの集合
以下の用に格納される

"time" は "time" : "\"time\""
t "time" は "t" : "\"time\""
"golang.org/x/text/cases" は "cases" : "\"golang.org/x/text/cases\""
n "golang.org/x/text/number" は "n" : "\"golang.org/x/text/number\""
*/
type importPackages map[string]string

// generateImportSpec はimport句の記述を生成する
func (rcv importPackages) generateImportSpec() string {
	if rcv == nil || len(rcv) == 0 {
		return ""
	}

	res := "import (\n"
	for k, v := range rcv {
		res = res + "\t" + k + " " + v + "\n"
	}
	res = res + ")\n"
	return res
}

// setAtTarget はrcvのkeyの値を、targetにセットする
func (rcv importPackages) setAtTarget(key string, target importPackages) {
	if value, ok := rcv[key]; ok {
		target[key] = value
	}
}

var (
	// fileTmpl はファイルテンプレート
	fileTmpl = template.Must(template.New("out").Parse(`// Code generated by {{ .GeneratorName }}; DO NOT EDIT.
package {{ .PackageName }}

{{ .ImportPackages }}

{{ .Body }}
		`))

	// sliceTmpl はslice型の宣言のテンプレート
	sliceTmpl = template.Must(template.New("slice").Parse(`
// {{ .TypeName }}Slice is {{ .TypeName }} slice.
type {{ .TypeName }}Slice []{{ .NodeType }}

// Filter returns a itself consisting of the elements of this slice that match the specified function.
func (rcv {{ .TypeName }}Slice) Filter(f func({{ .NodeType }}) bool) {{ .TypeName }}Slice {
	l := make([]{{ .NodeType }}, 0, len(rcv))
	for _, v := range rcv {
		if f(v) {
			l = append(l, v)
		}
	}
	return l
}
	`))
)

// fileTmplParams はファイルのテンプレートで使用するパラメーター
type fileTmplParams struct {
	GeneratorName  string
	PackageName    string
	ImportPackages string
	Body           string
}

// sliceTmplParams はslice型の宣言のテンプレートで使用するパラメーター
type sliceTmplParams struct {
	TypeName string // 型名
	NodeType string // 要素の型名（structの場合はポインタ、リテラル型の場合は実体の型）
}

// Generate はfileNameのファイルを解析してファイルの中身を返す.
// ここではサンプルとして、スライスを生成する。
func Generate(fileName string, types TargetTypes, generatorName string, debug bool) ([]byte, error) {
	// FileSetを生成
	// FileSetについてはここをみるべし
	// https://qiita.com/tenntenn/items/13340f2845316532b55a#tokenfileset
	fset := token.NewFileSet()

	// fにはファイルを解析した結果が入る
	// see: https://golang.org/pkg/go/ast/#File
	f, err := parseFile(fset, fileName)
	if err != nil {
		return nil, err
	}

	// すべてのimportパッケージを取得する
	allImportPackages := getAllImportPackages(f)

	// ファイルに出力するimportを生成する
	fileImportPackages := importPackages(make(map[string]string, len(allImportPackages)))

	// 型の宣言を取得する
	typeSpecs := getAllTypeSpecs(f)

	// ここからコードを走査しつつ、生成していく

	// bodyに生成したコードを突っ込んでいく
	body := new(bytes.Buffer)

	// 型の宣言の数だけloop
	for _, v := range typeSpecs {

		// 型名が処理対象の型リストに含まれないときは処理対象外（処理をスキップ）
		if !types.contains(v.Name.Name) {
			continue
		}

		/*
			もし、structを解析してコードを生成したい時（例：getterとか）は
			以下のコメントアウトを外して処理を書く
		 */

		// vがstructの時だけ以下動く
		//if structSpec, ok := v.Type.(*ast.StructType); ok {
		//	// フィールドの数だけループ
		//	for _, v := range structSpec.Fields.List {
		//
		//		/*
		//			ここでフィールドを読んでbodyに突っ込んでいく処理を書く
		//			以下は例
		//
		//			if err := hogeTmpl.Execute(body, hogeParams{
		//				Hoge: "",
		//				Fuga: "",
		//			}); err != nil {
		//				panic(err)
		//			}
		//
		//		 */
		//
		//		// フィールドの型が外部のパッケージの時はfileImprtPackagesにセットする
		//		setFileImportPackages(fset, v, allImportPackages, fileImportPackages)
		//	}
		//}

		// コンストラクタの生成
		// 生成したバイト文字列をbodyに突っ込む
		if err := sliceTmpl.Execute(body, sliceTmplParams{
			TypeName: v.Name.Name,
			NodeType: getNodeTypeName(v),
		}); err != nil {
			panic(err)
		}
	}

	// bodyが空の時は何もしない
	if body.Len() == 0 {
		return nil, nil
	}

	// ファイルの中身を生成する
	out := new(bytes.Buffer)
	err = fileTmpl.Execute(out, fileTmplParams{
		GeneratorName:  generatorName,
		PackageName:    f.Name.Name,
		ImportPackages: fileImportPackages.generateImportSpec(),
		Body:           body.String(),
	})

	if err != nil {
		return nil, err
	}

	// デバッグ用
	if debug {
		fmt.Println(string(out.Bytes()))
	}

	// 最後にフォーマットをかける。生成したファイルに構文エラーがあるとエラーになる
	_, err = format.Source(out.Bytes())
	if err != nil {
		return nil, err
	}

	return out.Bytes(), nil
}

// setFileImportPackages はtargetにimportパッケージをセットする
func setFileImportPackages(fset *token.FileSet, v *ast.Field, all importPackages, target importPackages) {
	b := new(bytes.Buffer)
	err := printer.Fprint(b, fset, v.Type)
	if err != nil {
		panic(err)
	}
	s := strings.Split(b.String(), ".")

	// len(s) > 0のときは、すなわち外部パッケージで定義された型のとき
	if len(s) > 0 {
		all.setAtTarget(s[0], target)
	}
}

// parseFile はファイルをパースする
func parseFile(fset *token.FileSet, fileName string) (*ast.File, error) {
	f, err := parser.ParseFile(fset, fileName, nil, parser.Mode(0))
	if err != nil {
		return nil, err
	}
	return f, nil
}

// getAllImportPackages はファイルのimportに記載された全てのimportパッケージを取得する
func getAllImportPackages(f *ast.File) importPackages {
	m := make(map[string]string, len(f.Imports))
	for _, v := range f.Imports {
		if name := v.Name; name != nil {
			m[name.Name] = v.Path.Value
			continue
		}
		value := v.Path.Value
		path := strings.Split(strings.Trim(value, "\""), "/")
		key := path[len(path) - 1]
		m[key] = value
	}
	return m
}

// getAllGenDecls は全てのGenDeclを取得する
// GenDeclはvar、const、type、importの宣言のこと
// see: https://golang.org/pkg/go/ast/#GenDecl
func getAllGenDecls(f *ast.File) []*ast.GenDecl {
	l := make([]*ast.GenDecl, 0, len(f.Decls))
	for _, v := range f.Decls {
		decl, ok := v.(*ast.GenDecl)
		if !ok {
			continue
		}
		l = append(l, decl)
	}
	return l
}

// getAllTypeSpecs は型に関しての宣言を取得する
// see: https://golang.org/pkg/go/ast/#TypeSpec
func getAllTypeSpecs(f *ast.File) []*ast.TypeSpec {
	decls := getAllGenDecls(f)
	l := make([]*ast.TypeSpec, 0, len(decls))
	for _, decl := range decls {
		if decl.Tok != token.TYPE {
			continue
		}
		for _, spec := range decl.Specs {
			l = append(l, spec.(*ast.TypeSpec))
		}
	}
	return l
}

// getNodeTypeName はスライスのノードの型名を返す
func getNodeTypeName(typeSpec *ast.TypeSpec) string {
	_, ok := typeSpec.Type.(*ast.StructType)
	if ok {
		return "*" + typeSpec.Name.Name
	}
	return typeSpec.Name.Name
}